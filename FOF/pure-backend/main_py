import warnings
from urllib3.exceptions import InsecureRequestWarning
from flask import Flask, request
from flask_restx import Api, Resource, fields
from jira import JIRA, exceptions
from config import Config

# Initialize Flask application
app = Flask(__name__)
app.config.from_object(Config)

# Disable SSL warnings
warnings.filterwarnings("ignore", category=InsecureRequestWarning)

# Initialize Jira connection
try:
    jira = JIRA(
        server=Config.JIRA_SERVER,
        basic_auth=(Config.JIRA_EMAIL, Config.JIRA_API_TOKEN),
        verify_ssl=False  # Disable SSL verification (not recommended for production)
    )
except exceptions.JIRAError as e:
    app.logger.error(f"Jira connection failed: {str(e)}")
    jira = None

# Initialize Swagger documentation
api = Api(
    app,
    version='1.4',
    title='Jira API Proxy Service',
    description='A Flask service to expose Jira APIs with detailed documentation',
    doc='/docs/'
)

# -------------------------- API Models --------------------------
issue_model = api.model('Issue', {
    'project': fields.String(required=True, description='Project key (e.g., "PROJ" for project PROJ)'),
    'issuetype': fields.String(required=True, description='Type of issue (e.g., "Task", "Bug", "Epic")'),
    'summary': fields.String(required=True, description='Brief title of the issue (max 255 characters)'),
    'description': fields.String(description='Detailed description of the issue (supports markdown)'),
    'priority': fields.String(description='Priority level (e.g., "High", "Medium", "Low"; default: "Medium")'),
    'custom_fields': fields.Raw(description='Optional custom fields (format: {"customfield_10000": "value"})')
})

transition_model = api.model('Transition', {
    'transition': fields.String(required=True, description='Name of the status transition (e.g., "In Progress", "Done")'),
    'comment': fields.String(description='Optional comment for the transition')
})

# -------------------------- Namespaces --------------------------
ns_issue = api.namespace('issues', description='Endpoints for managing Jira issues')


# Error handling decorator
def handle_jira_errors(func):
    def wrapper(*args, **kwargs):
        if not jira:
            return {'error': 'Jira service connection failed'}, 500
        try:
            return func(*args, **kwargs)
        except exceptions.JIRAError as e:
            return {'error': str(e)}, e.status_code
        except Exception as e:
            return {'error': f'Server error: {str(e)}'}, 500
    return wrapper


# -------------------------- Issue Endpoints --------------------------
@ns_issue.route('')
@api.doc(description='Create new issues or search existing issues')
class IssueList(Resource):
    @handle_jira_errors
    @api.doc(
        description='Search issues using JQL (Jira Query Language) with pagination and custom fields',
        params={
            'jql': 'JQL query to filter issues (e.g., "project=PROJ AND status=\'Open\'"; default: "project is not empty")',
            'maxResults': 'Maximum number of results to return (default: 20; max: 1000)',
            'startAt': 'Pagination offset (default: 0; use for fetching next pages)',
            'fields': 'Comma-separated list of fields to return (e.g., "summary,status,assignee"; default: "id,key,summary,status,assignee")'
        },
        responses={
            200: 'Successfully retrieved issues',
            400: 'Invalid JQL query',
            500: 'Server or Jira connection error'
        }
    )
    def get(self):
        """Search and retrieve issues with filtering"""
        jql = request.args.get('jql', 'project is not empty')
        max_results = int(request.args.get('maxResults', 20))
        start_at = int(request.args.get('startAt', 0))
        fields = request.args.get('fields', 'id,key,summary,status,assignee')
        
        issues = jira.search_issues(
            jql,
            maxResults=max_results,
            startAt=start_at,
            fields=fields
        )
        
        result = []
        for issue in issues:
            issue_data = {'id': issue.id, 'key': issue.key}
            for field in fields.split(','):
                if hasattr(issue.fields, field):
                    field_value = getattr(issue.fields, field)
                    if field == 'assignee' and field_value:
                        issue_data[field] = {
                            'username': field_value.name,
                            'display_name': field_value.displayName
                        }
                    elif field == 'status' and field_value:
                        issue_data[field] = field_value.name
                    else:
                        issue_data[field] = str(field_value) if field_value else None
            result.append(issue_data)
        
        return {
            'total_issues': issues.total,
            'start_at': start_at,
            'max_results': max_results,
            'issues': result
        }

    @handle_jira_errors
    @api.doc(
        description='Create a new issue in Jira with specified fields',
        responses={
            201: 'Issue created successfully',
            400: 'Missing required fields or invalid data',
            500: 'Server or Jira connection error'
        }
    )
    @api.expect(issue_model)
    def post(self):
        """Create a new issue"""
        data = api.payload
        issue_fields = {
            'project': {'key': data['project']},
            'issuetype': {'name': data['issuetype']},
            'summary': data['summary'],
            'description': data.get('description', ''),
            'priority': {'name': data.get('priority', 'Medium')}
        }
        
        if 'custom_fields' in data:
            issue_fields.update(data['custom_fields'])
            
        issue = jira.create_issue(fields=issue_fields)
        return {
            'id': issue.id,
            'key': issue.key,
            'summary': issue.fields.summary,
            'status': issue.fields.status.name,
            'created_at': issue.fields.created,
            'url': issue.permalink()
        }, 201


@ns_issue.route('/<string:issue_key>/transitions')
@api.doc(
    description='Manage status transitions for a specific issue',
    params={'issue_key': 'Unique key of the issue (e.g., "PROJ-123")'},
    responses={
        404: 'Issue not found'
    }
)
class IssueTransitions(Resource):
    @handle_jira_errors
    @api.doc(
        description='Get all available status transitions for the issue',
        responses={
            200: 'Successfully retrieved transitions'
        }
    )
    def get(self, issue_key):
        """Get available status transitions"""
        transitions = jira.transitions(issue_key)
        return [{
            'id': t['id'],
            'name': t['name'],
            'from_status': t['from']['name'] if 'from' in t else None,
            'to_status': t['to']['name']
        } for t in transitions]

    @handle_jira_errors
    @api.doc(
        description='Execute a status transition to change the issue\'s state',
        responses={
            200: 'Transition executed successfully',
            400: 'Invalid transition name'
        }
    )
    @api.expect(transition_model)
    def post(self, issue_key):
        """Execute a status transition"""
        data = api.payload
        transition_name = data['transition']
        comment = data.get('comment', '')
        
        # Find transition ID by name (case-insensitive)
        transitions = jira.transitions(issue_key)
        transition = next(
            (t for t in transitions if t['name'].lower() == transition_name.lower()),
            None
        )
        
        if not transition:
            return {'error': f'Transition "{transition_name}" not found for issue {issue_key}'}, 400
        
        # Execute transition with optional comment
        transition_args = {'transition': transition['id']}
        if comment:
            transition_args['comment'] = comment
        
        jira.transition_issue(issue_key,** transition_args)
        updated_issue = jira.issue(issue_key, fields='status,updated')
        
        return {
            'issue_key': issue_key,
            'transition_executed': transition_name,
            'previous_status': transition['from']['name'] if 'from' in transition else None,
            'current_status': updated_issue.fields.status.name,
            'updated_at': updated_issue.fields.updated,
            'comment': comment
        }


if __name__ == '__main__':
    app.run(host='0.0.0.0', port=Config.PORT)
